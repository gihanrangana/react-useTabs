{"version":3,"sources":["App.module.scss","components/UiTab/UiTabBar.module.scss","components/UiTab/UiTabBody.module.scss","lib/useTabs/TabBar.tsx","lib/useTabs/TabBody.tsx","components/UiTab/UiTab.tsx","App.tsx","lib/useTabs/UseTabs.tsx","serviceWorker.ts","index.tsx"],"names":["module","exports","TabBar","props","tabs","tabState","activeTabIndex","setActiveTab","tabStyles","onClick","useCallback","e","tab","index","preventDefault","onPress","name","renderItem","tabClass","tabItem","tabLabelClass","tabLabel","push","tabItemActive","tabLabelActive","ref","tabActiveRef","key","href","className","join","data-active","label","useEffect","offsetLeft","current","offsetWidth","tabIndicatorRef","style","left","width","useMemo","forwardedRef","tabBar","map","i","tabIndicator","TabBody","activeTab","useState","currentTab","setCurrentTab","currentTabIndex","setCurrentTabIndex","hide","setHide","useLayoutEffect","setTimeout","tabBodyRef","tabBody","tabContainer","render","UiTabBar","tabBarStyles","UiTabBody","tabBodyStyles","App","tabGroup","initialTabName","initialTab","initialTabIndex","setActiveTabState","activeTabName","activeTabNameState","setActiveTabIndexState","tabDirection","setTabDirection","tabName","tabBarRef","createRef","direction","useTabs","styles","container","title","Boolean","window","location","hostname","match","ReactDOM","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.ba0276b5.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"container\":\"container_1cmbG\",\"title\":\"title_27uMX\",\"tabContainer\":\"tabContainer_1-h0N\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"tabBar\":\"tabBar_3y5o-\",\"tabItem\":\"tabItem_2TGpX\",\"tabItemActive\":\"tabItemActive_2Gnm3\",\"tabIndicator\":\"tabIndicator_5kA_r\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"tabBody\":\"tabBody_2RWtL\"};","import React, { useCallback, useEffect, useMemo } from 'react'\r\n\r\nconst TabBar: React.FC<TabBarProps> = (props) => {\r\n\r\n    const { tabs, tabState, activeTabIndex, setActiveTab } = props;\r\n\r\n    const tabStyles = props.tabStyles || {};\r\n\r\n    const onClick = useCallback((e, tab, index) => {\r\n\r\n        e.preventDefault();\r\n\r\n        if (tab.onPress) {\r\n            tab.onPress(tab, tabState);\r\n\r\n        } else if (props.onPress) {\r\n\r\n            props.onPress(tab, tabState);\r\n\r\n        } else {\r\n\r\n            setActiveTab(tab.name);\r\n\r\n        }\r\n\r\n    }, [tabs])\r\n\r\n    const renderItem = useCallback((tab, index) => {\r\n\r\n        const tabClass = [tabStyles.tabItem];\r\n        const tabLabelClass = [tabStyles.tabLabel];\r\n\r\n        if (index === activeTabIndex) {\r\n            tabClass.push(tabStyles.tabItemActive);\r\n            tabLabelClass.push(tabStyles.tabLabelActive);\r\n        }\r\n\r\n        return (\r\n            <a\r\n                ref={index === activeTabIndex ? props.tabActiveRef : null}\r\n                key={index}\r\n                href={`#${tab.name}`}\r\n                onClick={(e) => onClick(e, tab, index)}\r\n                className={tabClass.join(' ')}\r\n                data-active={index === activeTabIndex}\r\n            >\r\n\r\n                <span className={tabLabelClass.join(' ')}>{tab.label}</span>\r\n\r\n            </a>\r\n        )\r\n\r\n    }, [activeTabIndex])\r\n\r\n    useEffect(() => {\r\n\r\n        const offsetLeft = props.tabActiveRef?.current?.offsetLeft;\r\n        const offsetWidth = props.tabActiveRef?.current?.offsetWidth;\r\n        \r\n        props.tabIndicatorRef.current.style.left = offsetLeft + \"px\";\r\n        props.tabIndicatorRef.current.style.width = offsetWidth + \"px\";\r\n        \r\n    },[props])\r\n\r\n    return useMemo(() => (\r\n\r\n        <div\r\n            ref={props.forwardedRef}\r\n            className={tabStyles.tabBar}\r\n        >\r\n\r\n            {tabs.map((tab: any, i: any) => (\r\n\r\n                renderItem(tab, i)\r\n\r\n            ))}\r\n\r\n            <div ref={props.tabIndicatorRef} className={tabStyles.tabIndicator} />\r\n\r\n        </div>\r\n\r\n    ), [props])\r\n}\r\n\r\ninterface TabBarProps {\r\n    [key: string]: any;\r\n}\r\n\r\nexport default TabBar","import React, { useLayoutEffect, useMemo, useState } from 'react'\r\n\r\nconst TabBody: React.FC<TabBodyProps> = (props) => {\r\n\r\n    const { activeTab, activeTabIndex } = props;\r\n\r\n    const tabStyles = props.tabStyles || {};\r\n\r\n    const [currentTab, setCurrentTab] = useState(activeTab);\r\n    const [currentTabIndex, setCurrentTabIndex] = useState(activeTabIndex);\r\n\r\n    const [hide, setHide] = useState(false);\r\n\r\n    useLayoutEffect(() => {\r\n\r\n        if (currentTabIndex !== activeTabIndex) {\r\n\r\n            setHide(true);\r\n\r\n            setTimeout(() => {\r\n\r\n                setHide(false);\r\n\r\n                setCurrentTab(activeTab);\r\n                setCurrentTabIndex(activeTabIndex);\r\n\r\n            }, 300);\r\n\r\n        }\r\n\r\n    }, [activeTabIndex]);\r\n\r\n    return useMemo(() => {\r\n\r\n        return (\r\n            <div\r\n                key={currentTabIndex}\r\n                ref={props.tabBodyRef}\r\n                className={tabStyles.tabBody}\r\n            >\r\n\r\n                <div className={tabStyles.tabContainer}>\r\n                    {currentTab && currentTab.render && currentTab.render()}\r\n                </div>\r\n\r\n            </div>\r\n        )\r\n    }, [hide, currentTabIndex]);\r\n}\r\n\r\ninterface TabBodyProps {\r\n    [key: string]: any;\r\n}\r\n\r\nexport default TabBody","import React from 'react'\r\nimport { TabBar, TabBody } from '../../lib'\r\n\r\nimport tabBarStyles from './UiTabBar.module.scss'\r\nimport tabBodyStyles from './UiTabBody.module.scss'\r\n\r\nconst UiTabBar: React.FC<UiTabBarProps> = (props) => {\r\n\r\n    return (\r\n        <>\r\n            <TabBar\r\n                {...props}\r\n                tabStyles={tabBarStyles}\r\n            />\r\n        </>\r\n    )\r\n}\r\n\r\nconst UiTabBody: React.FC<UiTabBodyProps> = (props) => {\r\n\r\n    return (\r\n        <>\r\n            <TabBody\r\n                {...props}\r\n                tabStyles={tabBodyStyles}\r\n            />\r\n        </>\r\n    )\r\n}\r\n\r\ninterface UiTabBodyProps {\r\n    [key: string]: any;\r\n}\r\n\r\ninterface UiTabBarProps {\r\n    [key: string]: any;\r\n}\r\n\r\n\r\nexport { UiTabBar, UiTabBody }","import React from 'react';\n\nimport styles from './App.module.scss';\nimport { UiTabBar, UiTabBody } from './components/UiTab/UiTab';\nimport { useTabs } from './lib';\n\nexport default function App() {\n\n    const tabs = [\n        {\n            name: 'tab1',\n            label: 'Tab 1',\n            render: () => {\n                return <p>Tab 1</p>\n            }\n        },\n        {\n            name: 'tab2',\n            label: 'Tab 2',\n            render: () => {\n                return <p>Tab 2</p>\n            }\n        },\n        {\n            name: 'tab3',\n            label: 'Tab 3',\n            render: () => {\n                return <p>Tab 3</p>\n            }\n        }\n    ];\n\n    const tabGroup = useTabs(tabs, 'tab2');\n\n    return (\n        <div className={styles.container}>\n\n            <h1 className={styles.title}>useTabs</h1>\n\n            <div className={styles.tabContainer}>\n\n                <UiTabBar\n                    {...tabGroup}\n                />\n\n                {/* <div> */}\n\n                <UiTabBody\n                    {...tabGroup}\n                />\n\n                {/* </div> */}\n\n            </div>\n\n        </div>\n    )\n}","import React, { createRef, useCallback, useState } from \"react\";\r\n\r\nconst useTabs = (tabs: Array<TabProps>, initialTabName?: string): TabGroup => {\r\n\r\n    initialTabName = initialTabName || tabs[0].name;\r\n\r\n    let initialTab: any, initialTabIndex;\r\n\r\n    tabs.map((tab, i) => {\r\n\r\n        if (!initialTab && tab.name === initialTabName) {\r\n            initialTab = tab;\r\n            initialTabIndex = i\r\n        }\r\n\r\n        return tab;\r\n    })\r\n\r\n    if (!initialTab && tabs[0]) {\r\n\r\n        initialTab = tabs[0];\r\n        initialTabIndex = 0;\r\n        initialTabName = initialTab.name;\r\n\r\n    }\r\n\r\n    const [activeTab, setActiveTabState] = useState(initialTab);\r\n\r\n    const [activeTabName, activeTabNameState] = useState(initialTabName);\r\n\r\n    const [activeTabIndex, setActiveTabIndexState]: any = useState(initialTabIndex);\r\n\r\n    const [tabDirection, setTabDirection] = useState('right');\r\n\r\n    const setActiveTab = useCallback((tabName) => {\r\n\r\n        tabs.map((tab, i) => {\r\n\r\n            if (tabName === tab.name) {\r\n\r\n                setTabDirection(i > activeTabIndex ? \"right\" : \"left\")\r\n\r\n                setActiveTabState(tab);\r\n                setActiveTabIndexState(i);\r\n                activeTabNameState(tab.name);\r\n            }\r\n\r\n            return tab\r\n        })\r\n\r\n    }, [activeTab, activeTabIndex])\r\n\r\n    return {\r\n        tabBarRef: createRef(),\r\n        tabBodyRef: createRef(),\r\n        tabActiveRef: createRef(),\r\n        tabIndicatorRef: createRef(),\r\n        tabs: tabs,\r\n        activeTab: activeTab,\r\n        activeTabName: activeTabName,\r\n        activeTabIndex: activeTabIndex,\r\n        setActiveTab: setActiveTab,\r\n        direction: tabDirection\r\n    }\r\n}\r\n\r\n\r\ninterface TabProps {\r\n    label: string,\r\n    name: string,\r\n    onPress?: any,\r\n    render?: any,\r\n}\r\n\r\ninterface TabGroup {\r\n    [key: string]: any;\r\n}\r\n\r\nexport { useTabs };\r\nexport * from './TabBar';\r\nexport * from './TabBody';","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './styles/web.scss';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}